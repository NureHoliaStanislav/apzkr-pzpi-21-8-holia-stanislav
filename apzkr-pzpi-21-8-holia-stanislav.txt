Міністерство освіти та науки України
Харківський національний університет радіоелектроніки


Факультет комп’ютерних наук

Кафедра програмної інженерії

КУРСОВА РОБОТА 
ПОЯСНЮВАЛЬНА ЗАПИСКА
з навчальної дисципліни «Архітектура програмного забезпечення»
Тема роботи: Програмна система для навчання військових, що імітує роботу мінних полів

Студент гр. ПЗПІ-21-8
__________________ Голя С. В.
(підпис)
Керівник роботи
__________________ ст.викл. Сокорчук І.П.
(підпис)

Роботу захищено «__»_________2024 р.
з оцінкою _________________________
Комісія:
__________________  доц. Лещинський В.О.
(підпис)
__________________ доц. Лещинська І.О.
(підпис)
__________________ ст.викл. Сокорчук І.П.
(підпис)

Харків 
2024 р.
Харківський національний університет радіоелектроніки

Факультет комп’ютерних наук         Кафедра програмної інженерії	      
Спеціальність 121 – Інженерія програмного забезпечення	
Курс           3		 Семестр  			            6			
Навчальна дисципліна Архітектура програмного забезпечення	

ЗАВДАННЯ
НА КУРСОВУ РОБОТУ СТУДЕНТОВІ
Голі Станіславу Володимировичу
    1. Тема роботи: «Програмна система для навчання військових що імітує роботу мінних полів»	
    2. Термін узгодження завдання курсової роботи «31» березня 2024 р.
    3. Термін здачі студентом закінченої роботи «10» червня 2024 р.
    4. Вихідні дані до проекту (роботи): В програмній системі передбачити:
унікальність, актуальність, розповсюдженість, масштабованість, підтримка інтернаціоналізації, локалізація, забезпечення конфіденційності та адміністрування системи, реалізація чотирьох компонентів (Back-end, Front-end, Mobile app, IoT)	
    5. Зміст пояснювальної записки (перелік питань, що належить розробити)
вступ, аналіз предметної області, постановка задачі, проєктування програмного проєкту, структура бази даних, розробка програмного проєкту, опис розробленої програмної системи, висновки, перелік посилань, додатки	
    6. Перелік графічного матеріалу (з точним зазначенням обов’язкових креслень) Deployment Diagram, Use Case Diagram, Entity-Relationship Model, Interaction Overview Diagram,  Activity Diagram, State Diagram, Component Diagram, Package Diagram	





КАЛЕНДАРНИЙ ПЛАН


Номер
Назва етапів курсової роботи
Строк виконання етапів роботи
Примітки
1
Функціональна специфікація програмного проєкту
31.03.24

2
Проєктування програмного проєкту
30.04.24

3
Кодування програмного проєкту
24.05.24

4
Оформлення пояснювальної записки
06.06.24

5
Захист курсової роботи
08.06.24


Дата видачі завдання «24» березня 2024 р.
Керівник
__________________ ст.викл. Сокорчук І.П.
(підпис)

Завдання прийняв до виконання
ст. гр. ПЗПІ-21-8
__________________      Голя С. В.
(підпис)

РЕФЕРАТ


Пояснювальна записка до курсової роботи: 68 с., 20 рис., 2 табл., 3 додатки, 5 джерел.
КОРИСТУВАЧ, КЛІЄНТ, МІНА, ПРОГРАМНА СИСТЕМА, РЕЗУЛЬТАТ, СЕРВЕР, СОЛДАТ, ТРЕНУВАННЯ, ІНСТРУКТОР, ЗАСТОСУНОК.

Технічним завданням на курсову роботу є створення масштабованої програмної системи. Як ідею для проєкту було обрано тему створення програмної системи для навчання військових, що буде імітувати роботу мінних полів.
У функціонал системи закладені можливості створювати та проводити тренування, імітувати мінні поля за допомогою пристроїв розумного інтернету, проводити аналіз пройдених тренувань. 
Набір технологій використаних при розробці програмної системи складається з Docker для розгортання серверів, Django Rest Framework з використанням мови програмування Python для серверної частини застосунку, серверу бази даних PostgreSQL, фреймворку React з використанням мови програмування JavaScript, мови C++ для імітації роботи пристрою речей розумного інтернету.
ЗМІСТ


ВСТУП	7
1 АНАЛІЗ ПРЕДМЕТНОЇ ОБЛАСТІ	8
 1.1 Бізнес-вимоги	8
 1.1.1 Бізнес-можливості	8
 1.1.2 Бізнес-цілі та критерії успіху	10
 1.1.3 Потреби клієнтів або ринку	11
 1.1.4 Бізнес-ризики	12
1.2.1 Окреслення концепції	13
1.2.2 Головна функціональність	14
1.2.3 Припущення та залежності	15
 1.3 Рамки та обмеження проєкту	15
1.3.1 Рамки первинного випуску	15
1.3.2 Рамки наступних випусків	17
1.3.3 Обмеження та винятки	18
 1.4 Бізнес-контекст	19
1.4.1 Профілі зацікавлених сторін	19
1.4.2 Пріоритети проєкту	21
1.4.3 Робоче середовище	21
2 ПОСТАНОВКА ЗАДАЧІ	23
3 ПРОЄКТУВАННЯ БАЗИ ДАНИХ	25
3.1 Побудова ER-діаграми	25
3.2 Побудова логічної моделі бази даних на основі ER-діаграми	27
4 АРХІТЕКТУРА ПРОГРАМНОЇ СИСТЕМИ	30
4.1 Архітектура серверної частини	30
4.2 Архітектура IoT частини	33
4.3 Архітектура клієнтської частини	36
5 ОПИС ПРОГРАМНОЇ СИСТЕМИ	40
5.1 Виклик і завантаження	40
5.2 Призначення і логічна структура	40
5.3 Опис програмної реалізації	42
ВИСНОВКИ	46
ПЕРЕЛІК ДЖЕРЕЛ ПОСИЛАННЯ	47
ДОДАТОК А	48
ДОДАТОК Б	60
ДОДАТОК В	64

ВСТУП


У будь-якому сучасному військовому конфлікті найціннішим ресурсом є кваліфіковані військові фахівці. Однією з найбільш актуальних проблем є замінована місцевість. За оцінками експертів, 30% території України наразі заміновано, що створює серйозні перешкоди під час операцій та становить значну загрозу для життя військовослужбовців.
В Збройних силах України є достатньо інструкторів, здатних навчити військових розпізнавати, уникати та знешкоджувати міни. Проте ці знання зазвичай не систематизуються в єдину програму навчання. Така ситуація є типовою і для багатьох інших країн, де зростає цінність військових фахівців і збільшується частота мінування.
Для вирішення цієї проблеми розроблено програмну систему «FieldForge», яка симулює міни та мінні поля для навчання військового персоналу і планування операцій. Користувачі системи зможуть планувати та проводити навчальні операції, а також аналізувати їх результати. Це підвищить ефективність підготовки військових та зменшить ризики, пов'язані із замінованою територією.
       1 АНАЛІЗ ПРЕДМЕТНОЇ ОБЛАСТІ
	1.1 Бізнес-вимоги
	1.1.1 Бізнес-можливості


На глобальному ринку існують системи для організації навчання військових, але вони не пропонують використання пристроїв інтернету речей (IoT) для організації навчального процесу. Враховуючи безпекові питання, у відкритому доступі складно знайти детальну інформацію про роботу таких програмних систем.
Розглянемо систему «ATMS» (https://www.aqtsolutions.com/training-management-systems/), що використовується армією США. «ATMS» здебільшого застосовується при навчанні пілотів, але може використовуватися як універсальна програмна система для організації навчання військових. Вона має такі характеристики:
    • підтримує розробку навчальних програм для всього персоналу, який потребує кваліфікаційного періодичного навчання;
    • визначає кваліфікацію інструктора, необхідну для викладання навчального курсу;
    • дозволяє завантажувати наявний вміст для безперебійного навчання в класі або електронного навчання;
    • відображає розклад за курсом із зазначенням наявності аудиторії, інструктора та слухачів;
    • повідомляє планувальника, коли стажер проходить або не відвідує навчальний захід;
    • веде повну історію підготовки стажерів та інструкторів;
    • надає повну та точну історію навчання для кожного студента;
    • надає можливість зберігати та друкувати сертифікати про навчання та ліцензійні документи;
    • забезпечує відстеження прогресу електронного навчання в реальному часі;
    • має чітку візуалізацію даних у реальному часі про те, що відбувається в навчальному відділі;
    • ­надає можливість повного налаштування аналітики та спеціального аналізу.
Для об'єктивного порівняння розглянемо ще дві системи, що створені для організації навчальних процесів, але не спеціалізуються на військових завданнях.
«Moodle» (https://moodle.org):
    • відкрита платформа для створення навчальних курсів та управління навчанням;
    • навчання включає віртуальні класи, електронні курси, офлайн тренінги;
    • відстеження прогресу навчання, інтеграція з іншими системами та інструментами;
    • не спеціалізується на військових потребах та симуляціях.
«D2L Brightspace» (https://www.d2l.com/brightspace):
    • платформа для управління навчанням з потужними аналітичними можливостями;
    • підтримка персоналізованих навчальних планів, відстеження прогресу, аналітика в реальному часі;
    • інтеграція з іншими системами для розширених можливостей навчання;
    • відсутність спеціалізованих функцій для військових тренувань.
Відмінність системи «FieldForge» полягає в зосередженні саме на роботі з мінними полями, що дозволяє зосередитись на аналітиці проведених навчань та максимально достовірно імітувати мінні поля. Система «ATMS», як і більшість інших систем цієї галузі, пропонує вирішення різних організаційних питань, тоді як призначення нашої системи спрямовано на вирішення конкретних проблем розмінування та подолання мінних полів. «FieldForge» пропонує симулювати мінні поля завдяки пристроям інтернету речей, проводити навчальні операції з подолання та розмінування цих мінних полів і в подальшому аналізувати результати операцій. Під час дослідження не було знайдено подібних систем, що використовують IoT для таких завдань.
Модель монетизації програмної системи передбачає місячну підписку на програмні застосунки в залежності від обраного плану, а також продаж смарт-девайсів за визначеними цінами. Наприклад, базовий план підписки може коштувати $100 на місяць, тоді як розширений план з додатковими функціями та аналітикою може коштувати $300 на місяць. Смарт-девайси, такі як датчики та контролери для симуляції мін, можуть продаватися окремо за ціною від $50 до $200 за одиницю залежно від функціональності.
Отже, системи для організації навчання військових існують, але «FieldForge» пропонує унікальні можливості для симуляції мінних полів з використанням IoT, що робить її неперевершеною для вирішення конкретних проблем, пов'язаних із замінованими територіями.


	1.1.2 Бізнес-цілі та критерії успіху


БЦ-1: Збільшити на 15% ефективність планування операцій в замінованих районах.
БЦ-2: Зменшити кількість загиблих та поранених військовослужбовців внаслідок мінно-вибухових пристроїв на 20% протягом 2 років.
БЦ-3: Скоротити час, необхідний для навчання військовослужбовців розпізнаванню, обходу та знешкодженню мін на 30%.
КУ-1: Досягнення кількісних цілей, описаних вище.
КУ-2: Збільшення економії коштів за рахунок зменшення втрат особового складу та скорочення часу навчання.
КУ-3: Позитивні відгуки від військовослужбовців та командування.
КУ-4: Зменшення кількості інцидентів, пов'язаних з мінно-вибуховими пристроями.


	1.1.3 Потреби клієнтів або ринку


У «FieldForge» є два основні види користувачів: інструктори з розмінування та солдати бойових підрозділів. 
Потреби інструкторів з розмінування: 
    • потреба в інструментах для створення та проведення тренувань з розмінування та штурмових дій, які враховують різноманітність місцевості та типів мін; 
    • потреба в більш реалістичних та захоплюючих методах навчання для підвищення мотивації та засвоєння матеріалу солдатами;
    • потреба в системі оцінки результатів навчання, яка дозволяє відстежувати прогрес солдатів та визначати сфери для вдосконалення. 
Потреби солдатів: 
    • потреба в практичному досвіді розмінування в реалістичних сценаріях; 
    • потреба в кращому розумінні методів виявлення та знешкодження мін, що підвищує їхню виживаність на полі бою;
    • потреба у впевненості у своїх здібностях під час розмінування або дій на замінованій території.  
Також є вимоги пов’язані з надійністю та зручністю системи:
    • інтерфейс користувача повинен бути інтуїтивно зрозумілим та простим у використанні, як для інструкторів, так і для солдатів з різним рівнем технічної підготовки;
    • система має забезпечувати надійне зберігання даних;
    • система повинна працювати ефективно навіть на пристроях з обмеженими апаратними ресурсами.


	1.1.4 Бізнес-ризики


Ризики:  
    • основними клієнтами є збройні сили, що обмежує загальний ринок збуту;
    • затримки розробки можуть призвести до того, що технологія застаріє або військові потреби зміняться;
    • військові можуть бути скептичними щодо нового методу навчання;
    • інтеграція «FieldForge» в існуючі навчальні програми може бути складною.
Можливі заходи: 
    • встановити чіткий графік розробки та використовувати методи управління проектами для мінімізації затримок;
    • провести ґрунтовне дослідження потреб військових та існуючих методів навчання;
    • запустити пілотну програму з обмеженою кількістю військових для отримання відгуків та оцінки ефективності;
    • залучити військових до розробки та тестування «FieldForge» для забезпечення відповідності їхнім потребам;
    • забезпечити належне навчання інструкторів щодо використання «FieldForge» для успішного впровадження.


1.2 Концепція рішення
               1.2.1 Окреслення концепції


Програмна система «FieldForge» ставить перед собою ціль покращити специфічні навички військових для протидії мінам та мінним полям шляхом інтерактивного тренування з залученням прототипів мін та симуляційних пристроїв. Продукт надає функціонал для створення тренувань як з розміновування, так і з штурмових дій, з урахуванням різних типів місцевості. Крім того, система використовує пристрої інтернету речей (IoT), що імітують реальні міни, для створення максимально реалістичних сценаріїв.
Основні функціональні можливості системи:
    • створення сценаріїв тренувань з розміновування та штурмових дій, які включають різні типи мін і мінних полів;
    • використання IoT пристроїв для імітації мін та їх розташування в різних типах місцевості;
    • збір та аналіз даних щодо проведених тренувань для оцінки ефективності навчання та виявлення слабких місць;
    • впровадження протоколів безпеки для мінімізації ризику травм та інцидентів під час тренувань;
    • навчання військових навичок роботи в різних типах місцевості та умовах.
Цільовими користувачами системи є інструктори та солдати. Інструктори відповідають за створення та проведення тренувальних програм, використання симуляцій та аналіз результатів навчання. Солдати проходять тренування з протидії мінам, набуваючи необхідних навичок для розпізнавання, знешкодження та обходу мін.
Система призначена для користування збройними силами, з метою підвищення ефективності навчання протидії мінам, забезпечення безпеки під час тренувань та покращення навичок роботи в різних умовах місцевості.


               1.2.2 Головна функціональність


ГФ-1. Реалістичне моделювання мін: «FieldForge» виходить за рамки традиційних методів навчання, моделюючи широкий спектр мін та мінних полів. Це включає підривні плити, розтяжки, спрямовані міни та протитанкові міни, що забезпечує реалістичний досвід навчання для солдатів.
ГФ-2. Планування та візуалізація місій: «FieldForge» дозволяє користувачам імпортувати дані з реального світу або створювати власні макети мінних полів. Це дозволяє командирам оцінювати ризики, планувати маршрути та розробляти тактику перед розгортанням.
ГФ-3. Аналіз та перегляд після дій: «FieldForge» надає детальні звіти про результати роботи солдатів, включаючи рівень виявлення мін, прийняття рішень та час, витрачений на виконання завдань. Це дозволяє інструкторам виявляти сфери для вдосконалення та відповідно адаптувати майбутні тренування.
ГФ-4. Масштабованість та адаптивність: «FieldForge» розроблений для задоволення різних потреб у навчанні. Програмне забезпечення дозволяє проводити індивідуальні або групові тренування з регульованим рівнем складності, щоб задовольнити солдатів з різним рівнем досвіду. Крім того, систему можна оновлювати, щоб відображати новітні типи мін та нові загрози. 
ГФ-5. Локалізація: «FieldForge» розроблений з урахуванням багатомовності та підтримки різних часових поясів та систем вимірювання. Це дозволяє користувачам з усього світу використовувати платформу зручною для них мовою, а також відображати інформацію відповідно до їх місцезнаходження.
ГФ-6. Керування через сайт та мобільний застосунок: «FieldForge» пропонує зручний інтерфейс керування як через веб-сайт, так і через мобільний додаток. Це дозволяє користувачам легко отримувати доступ до платформи та виконувати різні дії, незалежно від того, де вони знаходяться. 


               1.2.3 Припущення та залежності


П-1: Військові матимуть доступ до комп'ютерів та планшетів, які відповідають мінімальним технічним вимогам для запуску «FieldForge».
П-2: Збройні сили визнають переваги навчання з використанням симуляторів, яке пропонує «FieldForge».
З-1: Успіх «FieldForge» залежить від здатності розробників створити реалістичні навчальні середовища та симуляції мін. 
З-2: Успішне впровадження «FieldForge» потребуватиме тісної співпраці з військовими для забезпечення того, щоб система відповідала їхнім навчальним потребам та стандартам безпеки. 
З-3: Затвердження та підтримка з боку військового керівництва матиме вирішальне значення для широкого використання FieldForge.


	1.3 Рамки та обмеження проєкту
               1.3.1 Рамки первинного випуску


Програмна система «FieldForge» має на меті покращити навички військових у протидії мінам та мінним полям. Для досягнення цієї мети система реалізує широкий спектр функціональних можливостей як для інструкторів, так і для солдатів. Нижче наведено детальний опис функціональності системи, а також доповнення та виправлення недоліків попереднього опису.
Функціональність веб-застосунку для інструкторів з розмінування:
    • можливість реєструватися та авторизуватися, забезпечення доступу до системи тільки авторизованим користувачам;
    • розробка тренувальних сценаріїв, створення сценаріїв тренувань з урахуванням різних типів місцевості, мін та бойових завдань;
    • генерування детальних звітів про результати тренувань для оцінки прогресу солдатів та виявлення сфер для покращення;
    • моніторинг та аналіз індивідуальних показників солдатів під час тренувань;
    • додавання солдатів до тренування, доступ до тренувань та відстеження прогресу.
Функціональність веб-застосунку для солдатів:
    • можливість брати участь у тренуваннях, створених інструкторами;
    • можливість реєструватися та авторизуватися, забезпечення доступу до системи тільки авторизованим користувачам; 
    • перегляд власних результатів та статистичних даних;
    • аналіз допущених помилок для запобігання їх повторенню в реальних бойових умовах.
Адміністративна панель:
    • забезпечення доступу до адміністративної панелі тільки авторизованим адміністраторам;
    • блокування та розблокування користувачів;
    • призначення ролей та прав доступу для інших адміністраторів;
    • додавання та видалення мін з системи;
    • забезпечення функціональності резервного копіювання даних для відновлення системи у випадку виникнення проблем.
IoT модуль:
    • реакція на рух, що відповідає обраному типу міни, з використанням звукового супроводження;
    • механізм умов спрацювання на сервер для подальшого аналізу.
              Функціональність мобільного застосунку для інструкторів з розмінування:
    • реєстрація та авторизація, забезпечення доступу до системи через мобільний застосунок тільки авторизованим користувачам;
    • розробка тренувальних сценаріїв, створення та редагування сценаріїв тренувань з урахуванням різних типів місцевості та завдань;
    • генерування детальних звітів про результати тренувань;
    • моніторинг та аналіз індивідуальних показників солдатів;
    • керування профілями солдатів, доступом до тренувань та прогресом.
Функціональність мобільного застосунку для солдатів:
    • можливість брати участь у тренуваннях через мобільний застосунок.
    • перегляд власних результатів та статистичних даних.
    • отримання персоналізованого зворотного зв'язку від інструкторів.
    • аналіз допущених помилок для запобігання їх повторенню в реальних бойових умовах.
Захист даних:
    • захист даних користувачів всередині бази даних за допомогою шифрування та хешування;
    • дотримання чинних законів та норм про захист даних.
Вимоги до локалізації:
    • інтерфейс користувача доступний кількома мовами;
    • підтримка метричної та імперської систем вимірювання;
    • можливість налаштування системи під будь-який часовий пояс


               1.3.2 Рамки наступних випусків


У веб-застосунку та мобільному застосунку буде додано такий функціонал: 
    • підключення до існуючих систем навчання та інструментів для централізованого управління навчальними програмами;
    • адаптація навчальних сценаріїв та завдань до індивідуальних потреб та рівня підготовки солдатів;
    • забезпечення доступності навчальних матеріалів та звітів для солдатів у будь-який час та в будь-якому місці без підключення до мережі;
    • обмін тренувальними сценаріями та кращими практиками між інструкторами;
    • створення колективної бази знань для постійного вдосконалення навчальних програм.
Адміністратор у веб застосунку отримає такий функціонал: 
    • вести технічну підтримку користувачів.


               1.3.3 Обмеження та винятки


    • підтримка всіх типів мін: хоча «FieldForge» матиме базу даних з інформацією про різні типи мін, система може не охоплювати абсолютно всі типи мін, які існують. Буде потрібно регулярно оновлювати базу даних новими типами мін та методами їх виявлення;
    • використання реальних мін: «FieldForge» зосереджуватиметься на навчанні солдатів за допомогою пристроїв інтернету речей. Система не використовуватиме справжні міни під час тренувань через міркування безпеки;
    • версія операційної системи: для роботи системи на девайсі повинна бути встановлена відповідна версія операційної системи.
	1.4 Бізнес-контекст
               1.4.1 Профілі зацікавлених сторін


	Таблиця 1.1 – Профілі зацікавлених сторін проєкту




Кінець таблиці 1.1


               1.4.2 Пріоритети проєкту


Таблиця 1.2 – Пріоритети проєкту 
Показник
Виконання (етапи)
Обмеження (граничні значення)
Ступінь свободи
(допустимий діапазон)
План
Реліз 1.0 має бути випущеним до 08.06.2024


Функціональність



Якість



Персонал

Максимальний розмір команди це один розробник

Ціна


Можливе збільшення на 15%
 

               1.4.3 Робоче середовище


Для написання серверної частини програмної системи буде використана мова програмування Python та фреймворк Django. Django обрано через його потужні можливості для швидкої розробки та масштабованості. Фреймворк забезпечує високу швидкодію та підтримку безпеки, що є критично важливим для роботи з військовими даними. Django має вбудовані механізми аутентифікації та адміністрування, що полегшує розробку складних систем. 
Веб-застосунок буде створено на мові програмування JavaScript з використанням фреймворку React. React обрано через його високу продуктивність, компонентну структуру та можливість повторного використання компонентів, що значно спрощує розробку складних інтерфейсів. React також підтримує віртуальний DOM, що забезпечує високу швидкодію та ефективне оновлення інтерфейсу користувача. Використання JavaScript дозволяє інтегрувати React з іншими веб-технологіями та забезпечує широку підтримку серед розробників.
Мобільний застосунок буде розроблено мовою програмування Kotlin для операційної системи Android, використовуючи фреймворк Jetpack Compose та бібліотеки Dagger, Coil, Room, Retrofit. Kotlin обрано через його сучасну структуру, безпечність та сумісність з Java, що дозволяє використовувати існуючі бібліотеки. Jetpack Compose забезпечує спрощену декларативну розробку інтерфейсу користувача, що прискорює розробку та покращує підтримку додатку. Використання бібліотек Dagger, Coil, Room, Retrofit забезпечує ефективне управління залежностями, обробку зображень, роботу з базами даних та виконання мережевих запитів. 
Для збереження даних буде застосовано базу даних PostgreSQL. 
IoT модуль буде реалізовано на платі Raspberry Pi з використанням мови Python, модулів RPi.GPIO та Adafruit CircuitPython, а також датчиків руху та елементів живлення для автономної роботи.
Програмна система буде завантажена на хостинги Vultr та Render. Для захисту передачі даних між клієнтом і сервером буде використано протокол HTTPS, а запити будуть будуватися за принципами REST. Для аутентифікації та авторизації буде застосовано JWT токени. Середовища розробки включають Android Studio, PyCharm та WebStorm, а для системи контролю версій використовується Git з сервісом GitHub.

       2 ПОСТАНОВКА ЗАДАЧІ


За результатами попереднього аналізу предметної області, задачею курсової роботи було поставлено створення програмної системи для навчання військових, що імітує роботу мінних полів. База даних повинна включати інформацію про: користувачів, ролі, тренування, місцевості, пристрої (міни), та результати тренувань.
Функціонал для інструкторів з розмінування:
    • реєстрація та вхід в систему;
    • розробка тренувальних сценаріїв з урахуванням різних типів місцевості, мін та бойових завдань;
    • автоматичне генерування звітів про результати тренувань для оцінки прогресу солдатів та виявлення сфер для покращення;
    • відстеження індивідуальних показників солдатів;
    • створення та керування профілями солдатів, включаючи доступ до тренувань та відстеження прогресу.
Функціонал для солдатів:
    • реєстрація та вхід в систему;
    • проходження тренувань;
    • перегляд власних результатів та статистичних даних;
    • отримання персоналізованого зворотного зв'язку від інструкторів;
    • аналіз помилок для запобігання їх повторення в реальних бойових умовах.
Адміністративна панель:
    • реєстрація та вхід в систему;
    • керування користувачами системи;
    • перегляд, додавання, редагування, видалення профілів користувачів;
    • перегляд та керування тренуваннями;
    • перегляд та керування пристроями (мінами) та їх параметрами;
    • експорт та імпорт даних системи;
    • експорт та імпорт сертифікатів системи.
IoT модуль:
    • імітація міни: реакція на рух, що відповідає обраному типу міни, звукове супроводження;
    • механізм передачі часу та умов спрацювання на сервер для аналізу.
    • Мобільний застосунок для інструкторів з розмінування:
    • реєстрація та вхід в систему;
    • розробка тренувальних сценаріїв з урахуванням різних типів місцевості, мін та бойових завдань;
    • автоматичне генерування звітів про результати тренувань для оцінки прогресу солдатів та виявлення сфер для покращення;
    • відстеження індивідуальних показників солдатів;
    • створення та керування профілями солдатів, включаючи доступ до тренувань та відстеження прогресу.
Мобільний застосунок для солдатів:
    • реєстрація та вхід в систему;
    • проходження тренувань;
    • перегляд власних результатів та статистичних даних;
    • аналіз помилок для запобігання їх повторення в реальних бойових умовах.
Програмна система повинна підтримувати локалізацію та інтернаціоналізацію, а саме, забезпечувати:
    • підтримку різних кодових таблиць символів;
    • обчислення та формат дати та часу;
    • локальний та універсальний час;
    • метричні одиниці вимірювання;
    • англійську та американську систему мір;
    • порядок сортування текстових значень;
    • різні напрями введення тексту тощо.

       3 ПРОЄКТУВАННЯ БАЗИ ДАНИХ
           3.1 Побудова ER-діаграми


Для проектування бази даних було розроблено ER-модель даних (див. рис. 3.1). 


Рисунок 3.1 – ER-модель бази даних.

Сутність Users (Користувачі) – це сутність, яка містить інформацію про користувачів системи, і пов’язана зв’язком «один-до-багатьох» із сутністю Settings (Налаштування).
Сутність Settings (Налаштування) – це сутність, що містить інформацію про налаштування системи, і пов’язана зв’язком «багато-до-одного» із сутністю Users (Користувачі).
Сутність Tasks (Завдання) – це сутність, що містить інформацію про завдання, які створюються в системі, і пов’язана зв’язком «один-до-багатьох» із сутністю Results (Результати).
Сутність Results (Результати) – це сутність, що містить інформацію про результати виконаних завдань, і пов’язана зв’язком «багато-до-одного» із сутністю Tasks (Завдання).
Сутність Trainings (Тренування) – це сутність, що містить інформацію про тренування, і пов’язана зв’язком «багато-до-одного» із сутністю SoldiersTrainings (Тренування Солдатів) та зв’язком «один-до-багатьох» із сутністю Soldiers (Солдати).
Сутність Soldiers (Солдати) – це сутність, що містить інформацію про солдатів, і пов’язана зв’язком «багато-до-одного» із сутністю SoldiersTrainings (Тренування Солдатів) та зв’язком «один-до-багатьох» із сутністю Trainings (Тренування).
Сутність SoldiersTrainings (Тренування Солдатів) – це сутність, що містить інформацію про участь солдатів у тренуваннях, і пов’язана зв’язком «один-до-багатьох» із сутностями Soldiers (Солдати) та Trainings (Тренування).
Сутність Maps (Мапи) – це сутність, що містить інформацію про мапи, які використовуються в тренуваннях, і пов’язана зв’язком «багато-до-багатьох» із сутністю Mines (Міни) через сутність MapsMines (Мапи-Міни).
Сутність Mines (Міни) – це сутність, що містить інформацію про міни, і пов’язана зв’язком «багато-до-багатьох» із сутністю Maps (Мапи) через сутність MapsMines (Мапи-Міни).
Сутність MapsMines (Мапи-Міни) – це сутність, що містить інформацію про зв’язки між мапами та мінами, і пов’язана зв’язком «багато-до-одного» із сутностями Maps (Мапи) та Mines (Міни).
Сутність Instructors (Інструктори) – це сутність, що містить інформацію про інструкторів, і пов’язана зв’язком «багато-до-одного» із сутністю Trainings (Тренування).


           3.2 Побудова логічної моделі бази даних на основі ER-діаграми


Було розроблено діаграму логічної моделі бази даних (див. Рис. 3.2).


Рисунок 3.2 – Діаграма логічної моделі бази даних.

Розглянемо сутності логічної моделі бази даних.
Users (Користувачі):
    • атрибути: uuid, password, last_login, is_superuser, first_name, last_name, email, is_active, is_staff, created_at, updated_at, role;
    • зв'язки: один до одного з Settings.
    • Settings (Налаштування):
    • атрибути: uuid, time_zone, language, measurement_units, user_id;
    • зв'язки: один до одного з Users.
Tasks (Завдання):
    • атрибути: uuid, type, description, is_completed, training_id;
    • зв'язки: один до багатьох з Trainings.
Results (Результати):
    • атрибути: uuid, mines_activated, mines_passed, mines_defused, soldiers_lost, time_spent, training_id;
    • зв'язки: один до багатьох з Trainings
Trainings (Тренування):
    • атрибути: uuid, description, start_time, end_time, type, instructor_id;
    • зв'язки: один до багатьох з Tasks, Results, SoldiersTrainings, Maps та один до одного з Instructors.
Soldiers (Солдати):
    • атрибути: user_ptr_id, unit, specialization;
    • зв'язки: один до багатьох з SoldiersTrainings.
SoldiersTrainings (Тренування Солдатів):
    • атрибути: id, training_id, soldier_id;
    • зв'язки: один до багатьох з Soldiers, Trainings.
Maps (Мапи):
    • атрибути: uuid, description, start_point, end_point, training_id;
    • зв'язки: один до багатьох з Trainings; Один до одного з MapsMines.
Mines (Міни):
    • атрибути: uuid, type, range, is_activated, is_defused;
    • зв'язки: один до багатьох з MapsMines.
MapsMines (Мапи-Міни):
    • атрибути: uuid, location, map_id, mine_id;
    • зв'язки: один до одного з Maps; Один до одного з Mines.
Instructors (Інструктори):
    • атрибути: user_ptr_id, experience, specialization;
    • зв'язки: один до одного з Trainings.
Базу даних можна оцінити на відповідність нормальним формам. Відповідає 1 нормальній формі, оскільки всі атрибути містять атомарні значення та всі записи в таблицях унікальні. Відповідає 2 нормальній формі, оскільки всі непервинні атрибути залежать від первинних ключів відповідних таблиць. Відповідає 3 нормальній формі, оскільки всі непервинні атрибути залежать лише від первинних ключів своїх таблиць і не мають транзитивних залежностей.
База даних відповідає першій, другій та третій нормальним формам, що забезпечує уникнення аномалій при вставці, оновленні та видаленні даних, а також забезпечує логічну структуру і зв’язність даних.



       4 АРХІТЕКТУРА ПРОГРАМНОЇ СИСТЕМИ
           4.1 Архітектура серверної частини


	Користувачами розробленої системи є 3 типи акторів: солдат–відвідувач курсу, інструктор та адміністратор. 
Взаємодію кожної ролі користувачів з системою представлено на діаграмі прецедентів (див. рис. 4.1).


Рисунок 4.1 – Діаграма прецедентів користувачів системи.

Таким чином, за допомогою діаграми прецедентів було визначено функціональні потреби та взаємодію різних типів користувачів із системою.
Система має клієнт-серверну архітектуру, що складається з трьох рівнів: Клієнтський застосунок(веб-застосунок, мобільний застосунок), сервер на Django REST Framework, сервер бази даних PostgreSQL [4].
З серверного застосунку до бази даних здійснюється доступ за допомогою технології Django ORM, що надає зручний інтерфейс для взаємодії з базами даних у вигляді об’єктів сутностей.
Веб-сервер та сервер бази даних, будуть запускатись у Docker контейнерах, завдяки Docker Compose.
Для більш детальної візуалізації використаних технологій було розроблено діаграму розгортання (див. рис. 4.2).

Рисунок 4.2 – Діаграма розгортання.

Під час аналізу програмної системи було виділено кілька пакетів, які утворюють компоненти системи. Взаємозв'язки між цими пакетами проілюстровано на діаграмі пакетів (див. рис. 4.3). 


Рисунок 4.3 – UML діаграма пакетів серверної частини.

Пакет «djangoapp» є основним модулем мого проекту. Він містить всі важливі частини мого веб-додатку, включаючи моделі, представлення, URL-маршрути та інше. Пакет «URL Patterns» містить всі URL-маршрути мого додатку. Пакет «Serializers» містить «серіалізатори», які використовуються для перетворення даних моделей у формати, які можна легко передавати та працювати з ними, такі як JSON. Пакет «Views» містить представлення, які визначають, як приймати та обробляти запити надіслані серверу. Пакет «Models» містить моделі, що являють собою таблиці бази даних.
Архітектурою мого проекту є MV(Model, View), це стандартна архітектура що використовується Django REST Framework [1]. MV це похідна від MVC архітектура, що не має контролерів. Django сам виконує всі дії за котрі відповідає контролер в MVC.


           4.2 Архітектура IoT частини


	Користувачами розробленого IoT-модулю є 2 типи акторів: інструктор та солдат. 
Взаємодію кожної ролі користувачів з IoT-модулем представлено на діаграмі прецедентів (див. Рис. 1).








Рисунок 4.4 – Діаграма прецедентів IoT модулю системи “FieldForge”.

Таким чином, за допомогою діаграми прецедентів було визначено функціональні потреби та взаємодію різних типів користувачів із IoT-модулем.
У зв’язку з обмеженими технічними можливостями функціонал IoT-модулю було реалізовано на мові C++, що дозволяє портувати код на різні типи IoT-пристроїв.
Для користування програмою використовується консольний інтерфейс, налаштування пристрою (серійний номер та посилання на сервер) передаються через аргументи командної строки та зберігаються у файлі з форматом txt. Програма має функції для відправлення запитів, роботи з файлом налаштувань, імітації активації та розмінування міни.
Програма відправляє запити на сервер за допомогою бібліотеки cpr. Запит відправляється у форматі JSON з одним з двох полів: is_defused (інформація про те чи розмінували міну) та is_activated (інформація про те чи активували міну). На сервері ці дані використовуються для оновлення сутності міни.
Для написання серверної частини системи було обрано мову програмування С++. Проектним менеджером було обрано CMake, компілятором було обрано Clang. З додаткових бібліотек, була використана бібліотека cpr, котра дозволяє створювати та відправляти http запити.
	Для більш детальної візуалізації використаних технологій було розроблено діаграму пакетів (див. рис. 4.5).


Рисунок 4.5 – Діаграма пакетів для IoT-модулю системи “FieldForge”

Для більш детальної візуалізації взаємодії пристрою з користувачами системи було розроблено діаграму взаємодії (див. рис. 4.6).


Рисунок 4.6 – Діаграма взаємодії для IoT-модулю системи “FieldForge”

Також на основі взаємодії пристрою було побудовано діаграму діяльності, що відображає взаємодію пристрою з сервером (див. рис. 4.7).













Рисунок 4.7 – Діаграма діяльності для IoT-модулю системи “FieldForge”

Таким чином, за допомогою діаграм пакетів, взаємодії та діяльності було визначено основні технології та архітектуру системи.


           4.3 Архітектура клієнтської частини


Користувачами розробленої програмної системи є 2 типи акторів: інструктор та солдат. 
Взаємодію кожної ролі користувачів з системою представлено на діаграмі прецедентів (див. рис. 4.8).


Рисунок 4.8 – Діаграма прецедентів системи “FieldForge”

Таким чином, за допомогою діаграми прецедентів було визначено функціональні потреби та взаємодію різних типів користувачів із системою.
Клієнтська частина програмної системи розроблена на мові програмування JavaScript з використанням фреймворку React. Для стилізації інтерфейсу використовувався CSS. Також для побудови більшої частини інтерфейсу я використав Material UI, котрий надає готові, добре стилізовані компоненти, що дозволяє швидко створювати привабливі веб-інтерфейси. Для навігації по сайту був використаний react-router-dom, що забезпечує потужні засоби для створення динамічної навігації [2]. Для виконання асинхронних запитів використовувалась бібліотека axios. Клієнтський застосунок локалізований, за допомогою бібліотеки i18next, яка дозволяє легко реалізувати багатомовний інтерфейс та зручно переводити текстові елементи. Для візуалізації використаних пакетів було розроблено відповідну діаграму пакетів (див. Рисунок 4.9).


Рисунок 4.9 – Діаграма пакетів програмної системи «FieldForge»

Клієнтська частина проєкту організована згідно з архітектурною методологією Feature-Sliced Design, що передбачає розділення застосунку на різні шари - каталоги верхнього рівня [3]. У проєкті визначено 4 шари: shared, config, pages, app.
Шар shared: Тут містяться компоненти, що використовуються іншими частинами проєкту, в мене це заголовок сайту та сервіс аутентифікації.
Шар config: В цьому шарі знаходяться файли конфігурації. Наприклад, налаштування локалізації.
Шар pages: Тут знаходяться сторінки веб-сайту, які поділені на підкаталоги за їхньою функціональністю. Підкаталог сторінки містить ui сегмент та api сегмент, перший відповідає за інтерфейс, другий має код, що здійснює запити до серверу.
Шар app: Цей шар визначає основну конфігурацію застосунку, включаючи вхідну точку додатку та його головний компонент App.js.
Для кращого уявлення архітектури системи було створено діаграму компонентів, що дозволяє детально проаналізувати її структуру та взаємозв'язки між компонентами (див. рис. 4.10).


Рисунок 4.10 – Діаграма компонентів веб клієнту системи “FieldForge”

Використання програмної системи починається з авторизації – або створення нового профілю, або входу в уже створений. При цьому, створити профіль адміністратора неможливо.
В залежності від належності до адміністраторів, користувач отримує доступ до функціоналу адміністратора або користувача системи.
Користувач системи бачить свої тренування, адміністратор в свою чергу має доступ до сторінок для адміністрування системи, він може додавати та видаляти міни з системи, блокувати користувачів.
Користувач може перейти до власного профілю та переглянути інформацію про себе.
Для кращого уявлення про взаємодію користувачів з клієнтською частиною системи було розроблено діаграму взаємодії (див. рис. 4.11).


Рисунок 4.11 – Діаграма діяльності для IoT-модулю системи “FieldForge”

Це дозволило визначити основні технології та архітектуру системи через діаграми пакетів, компонентів та їх взаємодію. 


       5 ОПИС ПРОГРАМНОЇ СИСТЕМИ 
           5.1 Виклик і завантаження


Для того щоб запустити програму, необхідно спочатку завантажити архівний файл, який містить програму, і розпакувати його. Для роботи програмної системи на комп'ютері користувача повинні бути встановлені Cmake, npm, Docker та Docker Compose.
Для запуску серверної частини застосунку потрібно перейти за шляхом “apzkr-pzpi-21-8-holia-stanislav/Task1-Server/fieldforge/” у вашому терміналі, та  запустити по черзі команди “docker compose build” та “docker compose up”.
Для запуску веб клієнту програмної системи потрібно перейти за шляхом “apzkr-pzpi-21-8-holia-stanislav/Task3-WebClient/fieldforge” та запустити по черзі команди “npm install” та “npm start” у терміналі. Після проведення описаних дій, перейти за посиланням http://localhost:3000/ у своєму браузері.
Для запуску частини, що імітує IoT пристрій, потрібно перейти за шляхом “apzkr-pzpi-21-8-holia-stanislav/Task2-IoT/fieldforge_iot/build” у вашому терміналі. Після того як зробили крок описаний вище, потрібно по черзі запустити команди “cmake ..”, “make” та “./FieldForge”.


           5.2 Призначення і логічна структура


Функції, які може виконувати програма, можна розбити на декілька модулів, а саме: 
    • авторизація та реєстрація; 
    • тренування; 
    • міни; 
    • користувачі.
Модуль «Авторизація та реєстрація» містить у собі функції для входу в систему та створення нового облікового запису. Реєстрація дозволяє інструктору або солдату створити свій обліковий запис та надалі отримувати до нього доступ за допомогою своєї електронної пошти та пароля.
Модуль «Тренування» містить у собі функції для роботи з тренуваннями. Інструктор може: 
    • створювати тренування; 
    • встановлювати завдання на тренування; 
    • додавати до тренування солдатів;
    • додавати міни до тренування, встановлюючи їх розташування на мапі тренування;
    • заносити результати тренування та переглядати згенеровані системою результати тренування.
Користувачі можуть переглядати розклад своїх тренувань.
Модуль «Міни» містить у собі функції пов’язані з IoT пристроями, міни можуть надсилати на сервер інформацію про свій стан, сервер оброблює цю інформацію та повертає користувачу на клієнтський застосунок. Дані з мін прив’язаних до тренування систематизуються та сервер генерує показник успішності проведеної на тренуванні операції. Також адміністратори мають доступ до мін, вони можуть додавати міни до системи, вводячи їх серійний номер, та можуть видаляти міни з системи.
Модуль «Користувачі» містить у собі функції пов’язані з адмініструванням системи, адміністратори можуть переглядати всіх існуючих у системі користувачів та за необхідності блокувати їх облікові записи.


           5.3 Опис програмної реалізації


Перейшовши на веб-сторінку клієнтського застосунку, користувача зустрічає сторінка авторизації, доступ до системи не можливо отримати не авторизувавшись. На рисунку 5.1 можемо побачити сторінку входу в існуючий обліковий запис. 

Рисунок 5.1 – Сторінка входу в обліковий запис.

Також на рисунку 5.1 у верхньому правому куті можна побачити панель на котрій можна обрати мову застосунку (на даний момент присутня англомовна та україномовна версія сайту), або перейти до реїстрації. Сторінку реєстрації можна побачити на рисунку 5.2.

Рисунок 5.2 – Сторінка реєстрації облікового запису. 

Авторизований користувач може побачити дані свого облікового запису на відповідній сторінці (див. рис. 5.3).

Рисунок 5.3 – Сторінка з даними облікового запису. 

Користувач може переглядати розклад своїх тренувань на сторінці тренування. Можемо побачити це на рисунку 5.4.

Рисунок 5.4 – Сторінка з розкладом тренування користувача.

Авторизувавшись як адміністратор, користувач системи має змогу переглядати та блокувати облікові записи користувачів. Можемо побачити це на рисунку 5.5.

Рисунок 5.5 – Сторінка з функціоналом адміністрування системи.
Також адміністратор має змогу переглядати, видаляти та додавати міни до системи, можемо побачити це на рисунках 5.6 та 5.7.

Рисунок 5.6 – Сторінка з функціоналом для проведення операцій з мінами.

Рисунок 5.6 – Меню, що дозволяє додати міну у систему.
       ВИСНОВКИ


За результатами виконання роботи було розроблено програмну систему за темою «Програмна система для навчання військових що імітує роботу мінних полів». У процесі роботи було проаналізовано предметну область, досліджено вимоги користувачів та описано функціонал системи. Наступним кроком стало проектування архітектури системи. Було розроблено структуру бази даних, архітектуру серверної, IoT та клієнтської частин. Завершальним крокорм стала реалізація спроектованої програмної системи. Серверну частину було реалізовано за допомогою мови Python та фреймворку Django. Програму для IoT пристроїв було написано на мові C++, що дозволить портувати програму на різні види апаратного забезпечення. Клієнтську частину було розроблено на мові програмування JavaScript з використанням фреймворку React.
Розроблена програмна система повністю відповідає поставленим вимогам та забезпечує ефективне управління процесом навчання солдат. Використання сучасних технологій та підходів дозволило створити надійну, масштабовану та безпечну систему, яка забезпечує інтуїтивно зрозумілий інтерфейс користувача та високу продуктивність.
Система FieldForge може бути використана в реальних умовах для планування та проведення навчань, що дозволить значно підвищити ефективність та якість підготовки військових кадрів.





       ПЕРЕЛІК ДЖЕРЕЛ ПОСИЛАННЯ


1. Django Rest Framework Documentation. URL: https://www.django-rest-framework.org/ (дата звернення: 21.05.2024).
2. React documentation. URL: https://legacy.reactjs.org/docs/react-api.html (дата звернення: 02.06.2024).
3. Feature Sliced Design Overview. URL: https://feature-sliced.design/docs/get-started/overview (дата звернення: 03.06.2024).
4. Distributed Applications Engineering / Indrajit Wijegunaratne та George Fernandez. Addison-Wesley Professional, 1998.
5. Design Patterns: Elements of Reusable Object-Oriented Software. Erich Gamma, Richard Helm, Ralph Johnson, John Vlissides, 1994.

       ДОДАТОК А
Програмний код серверної частини
А.1 Код моделей бази даних.


  1  from django.contrib.gis.db import models
  2  from django.utils.translation import gettext_lazy as _
  3  from django.utils import timezone
  4  import uuid
  5  import pytz
  6  import jwt
  7  from datetime import datetime, timedelta
  8  from django.conf import settings 
  9  from django.forms.models import model_to_dict
 10  
 11  from django.contrib.auth.models import (
 12      AbstractBaseUser, BaseUserManager, PermissionsMixin
 13  )
 14  
 15  # Custom user manager
 16  class UserManager(BaseUserManager):
 17      def create_user(self, email, first_name, last_name, role, password=None, **extra_fields):
 18          # Check for required fields
 19          if email is None:
 20              raise TypeError('Users must have an email address.')
 21          if first_name is None:
 22              raise TypeError('Users must have a first name.')
 23          if last_name is None:
 24              raise TypeError('Users must have a last name.')
 25          if role is None:
 26              raise TypeError('Users must have a role.')
 27          if role not in ['INSTRUCTOR', 'SOLDIER']:
 28              raise ValueError('Role must be either "INSTRUCTOR" or "SOLDIER".')
 29  
 30          try:
 31              if role == 'INSTRUCTOR':
 32                   return self.create_instructor(email,first_name, last_name, password, role, **extra_fields)
 33              elif role == 'SOLDIER':
 34                   return self.create_soldier(email,first_name, last_name, password, role, **extra_fields)
 35          except ValueError:
 36              raise
 37  
 38      def create_admin(self, email, first_name, last_name, password=None):
 39          # Check for required fields
 40          if email is None:
 41              raise TypeError('Users must have an email address.')
 42          if first_name is None:
 43              raise TypeError('Users must have a first name.')
 44          if last_name is None:
 45              raise TypeError('Users must have a last name.')
 46  
 47          user = User(email=self.normalize_email(email=email),first_name=first_name, last_name=last_name)
 48          user.set_password(password)
 49          user.is_staff = True
 50          user.save()
 51  
 52          return user
 53  
 54      def create_instructor(self, email, first_name, last_name, password,role, **extra_fields):
 55          instructor_fields = {k: v for k, v in extra_fields.items() if k in ['experience', 'specialization']}
 56          if len(instructor_fields) \!= len(extra_fields):
 57              raise ValueError('Extra fields do not match the required fields for the Instructor role.')
 58          user = Instructor(email=self.normalize_email(email=email),first_name=first_name, last_name=last_name,role=role, **instructor_fields)
 59          user.set_password(password)
 60          user.save()
 61          return user
 62  
 63      def create_soldier(self, email, first_name, last_name, password,role, **extra_fields):
 64          soldier_fields = {k: v for k, v in extra_fields.items() if k in ['unit', 'specialization']}
 65          if len(soldier_fields) \!= len(extra_fields):
 66              raise ValueError('Extra fields do not match the required fields for the Soldier role.')
 67          user = Soldier(email=self.normalize_email(email=email),first_name=first_name, last_name=last_name,role=role, **soldier_fields)
 68          user.set_password(password)
 69          user.save()
 70          return user
 71  
 72      def create_superuser(self, email, first_name, last_name, role, password=None):
 73          # Check for required fields
 74          if password is None:
 75              raise TypeError('Superusers must have a password.')
 76  
 77          user = self.create_user(email, first_name, last_name, role, password)
 78          user.is_superuser = True
 79          user.is_staff = True
 80          user.save()
 81  
 82          return user
 83      
 84      def deactivate(self, uuid):
 85          # Deactivate user by setting is_active to False
 86          user = self.get(uuid=uuid)
 87          user.is_active = False
 88          user.save()
 89      
 90  
 91  # Custom user model
 92  class User(AbstractBaseUser, PermissionsMixin):
 93      uuid = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
 94      first_name = models.CharField(max_length=255)
 95      last_name = models.CharField(max_length=255)
 96      email = models.EmailField(db_index=True, unique=True)
 97      is_active = models.BooleanField(default=True)
 98      is_staff = models.BooleanField(default=False)
 99      created_at = models.DateTimeField(auto_now_add=True)
100      updated_at = models.DateTimeField(auto_now=True)
101      USERNAME_FIELD = 'email'
102      objects = UserManager()
103      ROLE_CHOICES = (
104          ('INSTRUCTOR', 'Instructor'),
105          ('SOLDIER', 'Soldier'),
106      )
107      role = models.CharField(max_length=10, choices=ROLE_CHOICES,blank=True)
108  
109      def __str__(self):
110          return self.email
111  
112      @property
113      def token(self):
114          return self._generate_jwt_token()
115  
116      def save(self, *args, **kwargs):
117          if not self.pk:
118              super(User, self).save(*args, **kwargs)
119              Settings.objects.create(user=self)
120          else:
121              super(User, self).save(*args, **kwargs)
122  
123      def get_full_name(self):
124          return self.last_name + ' ' + self.first_name
125  
126      def get_short_name(self):
127          return self.first_name
128  
129      def _generate_jwt_token(self):
130          dt = datetime.now() + timedelta(days=1)
131  
132          token = jwt.encode({
133              'id': str(self.pk),
134              'exp': int(dt.strftime('%s'))
135          }, settings.SECRET_KEY, algorithm='HS256')
136  
137          return token
138      
139      def fields_dict(self):
140          return model_to_dict(
141              User,
142              fields=[
143                  field.name
144                  for field in self._meta.fields
145                  if field.name in self.__dict__
146                  and field.name \!= self._meta.pk.name
147              ]
148          )
149  
150  # Instructor model
151  class Instructor(User):
152      experience = models.CharField(max_length=255)
153      specialization = models.CharField(max_length=255)
154  
155  
156  # Soldier model
157  class Soldier(User):
158      unit = models.CharField(max_length=255)
159      specialization = models.CharField(max_length=255)
160  
161  
162  # Training model
163  class Training(models.Model):
164      uuid = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
165      instructor = models.ForeignKey(Instructor, on_delete=models.PROTECT)
166      description = models.CharField(max_length=10000, blank=True)
167      start_time = models.DateTimeField(blank=True,null=True)
168      end_time = models.DateTimeField(blank=True, null=True)
169  
170      class TrainingTypes(models.TextChoices):
171          ASSAULT = 'Assault', _('Assault')
172          SCOUT = 'Scouting', _('Scouting')
173          DEMINING = 'Demining', _('Demining')
174          MIXED = 'Mixed', _('Mixed')
175  
176      type = models.CharField(
177          max_length=8,
178          choices=TrainingTypes.choices,
179          default=TrainingTypes.MIXED
180      )
181      soldiers = models.ManyToManyField(Soldier)
182  
183  
184  # Results model
185  class Results(models.Model):
186      uuid = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
187      training = models.OneToOneField(Training, on_delete=models.CASCADE)
188      mines_activated = models.IntegerField(default=0)
189      mines_passed = models.IntegerField(default=0)
190      mines_defused = models.IntegerField(default=0)
191      soldiers_lost = models.IntegerField(default=0)
192      time_spent = models.DurationField()
193  
194  
195  # Task model
196  class Task(models.Model):
197      uuid = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
198      training = models.ForeignKey(Training, on_delete=models.CASCADE)
199  
200      class TaskTypes(models.TextChoices):
201          ASSAULT = 'Assault', _('Assault')
202          SCOUT = 'Scouting', _('Scouting')
203          DEMINING = 'Demining', _('Demining')
204  
205      type = models.CharField(
206          max_length=8,
207          choices=TaskTypes.choices,
208          default=TaskTypes.DEMINING
209      )
210      description = models.CharField(max_length=10000, blank=True)
211      is_completed = models.BooleanField(default=False)
212  
213  
214  # Settings model
215  class Settings(models.Model):
216      uuid = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
217      user = models.OneToOneField(User, on_delete=models.CASCADE)
218  
219      TIMEZONES = tuple(zip(pytz.all_timezones, pytz.all_timezones))
220  
221      time_zone = models.CharField(max_length=32, choices=TIMEZONES,
222                                   default='UTC')
223  
224      class Language(models.TextChoices):
225          ENGLISH = 'EN', _('English')
226          UKRAINIAN = 'UA', _('Ukrainian')
227  
228      language = models.CharField(
229          max_length=2,
230          choices=Language.choices,
231          default=Language.ENGLISH
232      )
233  
234      class MeasurementUnits(models.TextChoices):
235          METRIC = 'MT', _('Metric')
236          IMPERIAL = 'IM', _('Imperial')
237  
238      measurement_units = models.CharField(
239          max_length=2,
240          choices=MeasurementUnits.choices,
241          default=MeasurementUnits.METRIC,
242      )
243  
244  
245  # Mine model
246  class Mine(models.Model):
247      uuid = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=True)
248  
249      class MineTypes(models.TextChoices):
250          TRIPWIRE = 'TW', _('Tripwire mine')
251          ANTIPERSONNEL = 'AP', _('Anti-personnel mine')
252  
253      type = models.CharField(
254          max_length=2,
255          choices=MineTypes.choices,
256          default=MineTypes.ANTIPERSONNEL,
257      )
258  
259      range = models.IntegerField(blank=True, null=True)
260      is_activated = models.BooleanField(default=False)
261      is_defused = models.BooleanField(default=False)
262  
263  
264  # Map model
265  class Map(models.Model):
266      uuid = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
267      training = models.OneToOneField(Training, on_delete=models.CASCADE)
268      mines = models.ManyToManyField(Mine, through='MapsMines')
269      description = models.CharField(max_length=10000, blank=True)
270      start_point = models.PointField(default='POINT(0 0)')
271      end_point = models.PointField(null=True, blank=True)
272  
273  
274  # MapsMines model
275  class MapsMines(models.Model):
276      uuid = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
277      map = models.ForeignKey(Map, on_delete=models.CASCADE)
278      mine = models.ForeignKey(Mine, on_delete=models.CASCADE)
279      location = models.PointField()


А.2 Код «серіалізаторів» для моделі користувача.


  1  from rest_framework import serializers # type: ignore
  2  from djangoapp.models import Instructor, Soldier, User 
  3  
  4  class InstructorSerializer(serializers.ModelSerializer):
  5      class Meta:
  6          model = Instructor  
  7          fields = ['experience', 'specialization']  # Specifying the fields to include in the serialized representation of the Instructor model
  8  
  9  class SoldierSerializer(serializers.ModelSerializer):
 10      class Meta:
 11          model = Soldier  
 12          fields = ['unit', 'specialization']  # Specifying the fields to include in the serialized representation of the Soldier model
 13          
 14  class UserSerializer(serializers.ModelSerializer):
 15      # Defining a custom field for the password, which is write-only (not included in the serialized representation)
 16      password = serializers.CharField(
 17          max_length=128,
 18          min_length=8,
 19          write_only=True
 20      )
 21  
 22      class Meta:
 23          model = User
 24          # Specifying the fields to include in the serialized representation of the User model
 25          fields = ('uuid','first_name','last_name','email', 'password', 'token', 'role', 'is_staff','is_active')
 26          # Specifying the read-only fields (not included in the serialized representation)
 27          read_only_fields = ('uuid','token', 'role', 'is_staff','is_active')
 28  
 29      def to_representation(self, instance):
 30          representation = super().to_representation(instance)
 31          # If the user's role is 'INSTRUCTOR', include the serialized representation of the associated Instructor model
 32          if instance.role == 'INSTRUCTOR':
 33              instructor_data = InstructorSerializer(instance.instructor).data
 34              for key, value in instructor_data.items():
 35                  representation[key] = value
 36          # If the user's role is 'SOLDIER', include the serialized representation of the associated Soldier model
 37          elif instance.role == 'SOLDIER':
 38              soldier_data = SoldierSerializer(instance.soldier).data
 39              for key, value in soldier_data.items():
 40                  representation[key] = value
 41          return representation
 42  
 43      def update(self, instance, validated_data):
 44          # Update the instance with the validated data
 45          password = validated_data.pop('password', None)
 46  
 47          for key, value in validated_data.items():
 48              setattr(instance, key, value)
 49  
 50          # If a new password is provided, set it for the instance
 51          if password is not None:
 52              instance.set_password(password)
 53  
 54          # Save the instance
 55          instance.save()
 56  
 57          return instance
 58      
 59  class PublicUserSerializer(UserSerializer):
 60      class Meta(UserSerializer.Meta):
 61          # Exclude the 'token' field from the serialized representation
 62          fields = tuple([field for field in UserSerializer.Meta.fields if field \!= 'token'])


А.3 Код представлення для реєстрації користувача


   1  from rest_framework.response import Response # type: ignore
  2  from rest_framework import status # type: ignore
  3  from rest_framework.permissions import AllowAny # type: ignore
  4  from rest_framework.views import APIView # type: ignore
  5  from ..renderers import UserJSONRenderer
  6  from ..serializers import RegistrationSerializer
  7  
  8  class RegistrationAPIView(APIView):   
  9      permission_classes = (AllowAny,)
 10      # Setting the permission classes for the view. In this case, any user can access the view.
 11      
 12      renderer_classes = (UserJSONRenderer,)
 13      # Setting the renderer classes for the view. The view will use the UserJSONRenderer to render User objects.
 14  
 15      serializer_class = RegistrationSerializer
 16      # Setting the serializer class for the view. The view will use the RegistrationSerializer to serialize and deserialize user registration data.
 17  
 18      def post(self, request):
 19  
 20          user = request.data.get('user', {})
 21          # Getting the 'user' data from the request. If 'user' is not present, an empty dictionary is used.
 22  
 23          serializer = self.serializer_class(data=user)
 24          # Creating a serializer instance with the user data.
 25  
 26          serializer.is_valid(raise_exception=True)
 27  
 28          serializer.save()
 29          # Saving the serializer data. This will create a new User object.
 30  
 31          return Response(serializer.data, status=status.HTTP_201_CREATED)


А.4 Код представлення, що містить в собі бізнес логіку.


  1  class TrainingResultsView(generics.RetrieveAPIView):
  2      permission_classes = (IsAuthenticated,)
  3      serializer_class = ResultsSerializer
  4      queryset = Training.objects.all()
  5      lookup_field = 'uuid'
  6  
  7      def retrieve(self, request, *args, **kwargs):
  8          instance = self.get_object().results
  9          serializer = self.get_serializer(instance)
 10          response_data = serializer.data
 11          # Calculate the success percentage
 12          total_mines = instance.mines_activated + instance.mines_passed + instance.mines_defused
 13          if total_mines == 0:
 14              success_percentage = 0
 15          else:
 16              success_percentage = ((instance.mines_defused + instance.mines_passed) / total_mines) * 100
 17  
 18          # Subtract the ratio of soldiers_lost to total_mines from success_percentage
 19          if instance.soldiers_lost > 0 and total_mines > 0:
 20              success_percentage -= (instance.soldiers_lost / total_mines) * 100
 21  
 22          # Ensure success_percentage doesn't fall below 0
 23          success_percentage = max(success_percentage, 0)
 24  
 25          return Response({
 26              'results': response_data,
 27              'success_percentage': success_percentage
 28          })

       ДОДАТОК Б 
Програмний код застосунку для IoT пристрою


  1  #include <iostream>
  2  #include <fstream>
  3  #include <cpr/cpr.h>
  4  #include <string>
  5  #include <map>
  6  #include <random>
  7  
  8  
  9  
 10  // Function to read settings from a file
 11  std::map<std::string, std::string> readSettings() {
 12      std::map<std::string, std::string> settings;
 13      std::ifstream settings_file("settings.txt");
 14      if (settings_file.is_open()) {
 15          std::string line;
 16          while (std::getline(settings_file, line)) {
 17              size_t pos = line.find("=");
 18              if (pos \!= std::string::npos) {
 19                  std::string key = line.substr(0, pos);
 20                  std::string value = line.substr(pos + 1);
 21                  settings[key] = value;
 22              }
 23          }
 24          settings_file.close();
 25      }
 26      return settings;
 27  }
 28  
 29  // Function to write settings to a file
 30  void writeSettings(const std::map<std::string, std::string>& settings) {
 31      std::ofstream settings_file("settings.txt");
 32      if (settings_file.is_open()) {
 33          for (const auto& pair : settings) {
 34              settings_file << pair.first << "=" << pair.second << "\n";
 35          }
 36          settings_file.close();
 37      } else {
 38          std::cout << "Unable to open file\n";
 39      }
 40  }
 41  
 42  // Simulate data received from motion controller
 43  struct MotionData {
 44      bool motionDetected;
 45  };
 46  
 47  // Simulate data that represents the state of the mine
 48  struct DefusionData {
 49      bool isDefused;
 50  };
 51  
 52  // Function to imitate defusing of mine
 53  void defuseMine(DefusionData data) {
 54      if (data.isDefused) {
 55          std::cout << "Mine defused\!\n";
 56          std::map<std::string, std::string> settings = readSettings();
 57          std::string mine_uuid = settings["UUID"].c_str(); 
 58          std::string api_url = settings["URL"].c_str();
 59          cpr::Header headers{{"uuid", mine_uuid}};
 60          cpr::Payload payload{{"is_defused", "true"}};
 61  
 62          auto response = cpr::Put(cpr::Url{api_url}, headers, payload);
 63  
 64          std::cout << "Status code: " << response.status_code << std::endl;
 65          std::cout << "Response body: " << response.text << std::endl;
 66  
 67      } else {
 68          std::cout << "Mine not defused.\n";
 69      }
 70  }
 71  
 72  // Function to imitate activation of mine
 73  void activateMine(MotionData data) {
 74      if (data.motionDetected) {
 75          std::cout << "Mine activated\!\n";
 76          std::map<std::string, std::string> settings = readSettings();
 77          std::string mine_uuid = settings["UUID"].c_str(); 
 78          std::string api_url = settings["URL"].c_str();
 79          cpr::Header headers{{"uuid", mine_uuid}};
 80          cpr::Payload payload{{"is_activated", "true"}};
 81  
 82          auto response = cpr::Put(cpr::Url{api_url}, headers, payload);
 83  
 84          std::cout << "Status code: " << response.status_code << std::endl;
 85          std::cout << "Response body: " << response.text << std::endl;
 86  
 87      } else {
 88          std::cout << "No motion detected. Mine not activated.\n";
 89      }
 90  }
 91  // Simulate receiving data from motion controller
 92  MotionData receiveActivationData() {
 93      std::random_device rd;
 94      std::mt19937 gen(rd());
 95      std::uniform_int_distribution<> dis(0, 9);
 96      return {dis(gen) == 0};
 97  }
 98  
 99  // Simulate receiving data about the state of the mine
100  DefusionData receiveDefusionData() {
101      std::random_device rd;
102      std::mt19937 gen(rd());
103      std::uniform_int_distribution<> dis(0, 9);
104      return {dis(gen) == 0};
105  }
106  
107  // Function to reset the mine state
108  void resetMine() {
109      std::cout << "Resetting mine.\n";
110      std::map<std::string, std::string> settings = readSettings();
111      std::string mine_uuid = settings["UUID"].c_str(); 
112      std::string api_url = settings["URL"].c_str();
113      cpr::Header headers{{"uuid", mine_uuid}};
114      cpr::Payload payload{{"is_activated", "false"}, {"is_defused", "false"}};
115  
116      auto response = cpr::Put(cpr::Url{api_url}, headers, payload);
117  
118      std::cout << "Status code: " << response.status_code << std::endl;
119      std::cout << "Response body: " << response.text << std::endl;
120  }
121  
122  int main() {
123      std::map<std::string, std::string> settings = readSettings();
124      
125      if (settings["URL"].empty() || settings["UUID"].empty()) {
126          
127          std::cout << "Enter URL: ";
128          std::getline(std::cin, settings["URL"]);
129  
130          std::cout << "Enter UUID: ";
131          std::getline(std::cin, settings["UUID"]);
132          
133          writeSettings(settings);
134      }
135      
136      resetMine();
137  
138      while (true) {
139          MotionData motionData = receiveActivationData();
140          DefusionData defusionData = receiveDefusionData();
141          if (motionData.motionDetected) {
142              activateMine(motionData);
143              return 0;
144          }
145  
146          if (defusionData.isDefused) {
147              defuseMine(defusionData);
148              return 0;
149          }
150          printf("...\n");
151          // Sleep for a while to simulate the delay in receiving data
152          std::this_thread::sleep_for(std::chrono::seconds(1));
153      }
154  
155  }



       ДОДАТОК В 
Програмний код веб клієнта
В.1 Код сторінки реєстрації


  1  import React, { useState } from 'react';
  2  import AuthService from '../../shared/AuthService';
  3  import './SignUp.css';
  4  import { useTranslation } from 'react-i18next';
  5  
  6  function SignUp({ onLogin }) {
  7    const { t } = useTranslation();
  8    const [unit, setUnit] = useState('');
  9    const [email, setEmail] = useState('');
 10    const [password, setPassword] = useState('');
 11    const [firstName, setFirstName] = useState('');
 12    const [lastName, setLastName] = useState('');
 13    const [role, setRole] = useState('SOLDIER');
 14    const [experience, setExperience] = useState('');
 15    const [specialization, setSpecialization] = useState('');
 16    const [error, setError] = useState(null);
 17  
 18    const handleSubmit = (event) => {
 19      event.preventDefault();
 20      let user = {
 21        email,
 22        password,
 23        first_name: firstName,
 24        last_name: lastName,
 25        role,
 26      };
 27    
 28      if (role === 'SOLDIER') {
 29        user = { ...user, unit, specialization };
 30      } else if (role === 'INSTRUCTOR') {
 31        user = { ...user, experience, specialization };
 32      }
 33      AuthService.signup({ 
 34        user
 35      })
 36        .then(user => {
 37          onLogin(user);
 38          setError(null);
 39        })
 40        .catch(error => {
 41          setError(error.message);
 42          console.error(error);
 43        });
 44    };
 45  
 46    return (
 47      <div className="sign-up-container">
 48        <h2>{t('Sign Up')}</h2>
 49        <form onSubmit={handleSubmit} className="sign-up-form">
 50          <input type="email" value={email} onChange={e => setEmail(e.target.value)} placeholder={t('Email')} required />
 51          <input type="password" value={password} onChange={e => setPassword(e.target.value)} placeholder={t('Password')} required />
 52          <input type="text" value={firstName} onChange={e => setFirstName(e.target.value)} placeholder={t('First Name')} required />
 53          <input type="text" value={lastName} onChange={e => setLastName(e.target.value)} placeholder={t('Last Name')} required />
 54          <select value={role} onChange={e => setRole(e.target.value)} required>
 55            <option value="SOLDIER">{t('Soldier')}</option>
 56            <option value="INSTRUCTOR">{t('Instructor')}</option>
 57          </select>        
 58          {role === 'SOLDIER' ? (
 59            <input type="text" value={unit} onChange={e => setUnit(e.target.value)} placeholder={t('Unit')} required />
 60          ) : (
 61            <input type="text" value={experience} onChange={e => setExperience(e.target.value)} placeholder={t('Experience')} required />
 62          )}        
 63          <input type="text" value={specialization} onChange={e => setSpecialization(e.target.value)} placeholder={t('Specialization')} required />
 64          <button type="submit" className='sign-up-button'>{t('Sign Up')}</button>
 65        </form>
 66        {error && <p>{t(error)}</p>}
 67      </div>
 68    );
 69  }
 70  
 71  export default SignUp;


В.2 Код сервісу для аутентифікації


  1  import axios from 'axios';
  2  import { jwtDecode } from 'jwt-decode';
  3  axios.defaults.baseURL = 'http://localhost:8000';
  4  class AuthService {
  5    async login(credentials) {
  6    
  7      const response = await axios
  8        .post('/api/user/login', credentials);
  9      const token = response.data.user.token;
 10      if (typeof token === 'string') {
 11        localStorage.setItem('token', token);
 12        return jwtDecode(token);
 13      }
 14      throw new Error('Token is not a string');
 15    }
 16  
 17    logout() {
 18      localStorage.removeItem('token');
 19    }
 20  
 21    async signup(userDetails) {
 22      const response = await axios
 23        .post('/api/user/sign-up', userDetails);
 24      const token = response.data.user.token;
 25      if (typeof token === 'string') {
 26        localStorage.setItem('token', token);
 27        return jwtDecode(token);
 28      }
 29      throw new Error('Token is not a string');
 30    }
 31  
 32    async getCurrentUser() {
 33      try {
 34        const token = localStorage.getItem('token');
 35        const response = await axios
 36        .get('/api/user',{
 37          headers: {
 38            'Authorization': `Token ${token}`
 39          }
 40        });
 41        const user = response.data.user;
 42        return user;
 43      } catch (ex) {
 44        return null;
 45      }
 46    }
 47  }
 48  
 49  const authServiceInstance = new AuthService();
 50  
 51  export default authServiceInstance;



В.3 Код компоненту Header.jsx


  1  import React from 'react';
  2  import AppBar from '@mui/material/AppBar';
  3  import Toolbar from '@mui/material/Toolbar';
  4  import Typography from '@mui/material/Typography';
  5  import Button from '@mui/material/Button';
  6  import Box from '@mui/material/Box';
  7  import AuthService from '../AuthService';
  8  import { useNavigate } from 'react-router-dom'; 
  9  import { useTranslation } from 'react-i18next';
 10  import Menu from '@mui/material/Menu';
 11  import MenuItem from '@mui/material/MenuItem';
 12  
 13  function Header({ user, onLogout }) {
 14    const navigate = useNavigate();
 15    const { t, i18n } = useTranslation();
 16    const [anchorEl, setAnchorEl] = React.useState(null);
 17  
 18    const handleProfile = () => {
 19      navigate('/profile');
 20    };
 21  
 22    const handleLogout = () => {
 23      AuthService.logout();
 24      onLogout();
 25    };
 26  
 27    const handleLogin = () => {
 28      navigate('/login'); 
 29    };
 30  
 31    const handleSignup = () => {
 32      navigate('/sign-up'); 
 33    };
 34  
 35    const handleMines = () => {
 36      navigate('/mines'); 
 37    };
 38  
 39    const handleUsers = () => {
 40      navigate('/users'); 
 41    };
 42  
 43    const handleTrainings = () => {
 44      navigate('/trainings');
 45    };
 46  
 47    const handleLanguageMenu = (event) => {
 48      setAnchorEl(event.currentTarget);
 49    };
 50  
 51    const handleLanguageChange = (lang) => {
 52      i18n.changeLanguage(lang);
 53      setAnchorEl(null);
 54    };
 55  
 56    return (
 57      <AppBar position="fixed" sx={{ backgroundColor: '#000' }}>
 58        <Toolbar>
 59          <Box sx={{ flexGrow: 1 }} />
 60          <Typography variant="h6" component="div" sx={{ position: 'absolute', left: '50%', transform: 'translateX(-50%)' }}>
 61            FieldForge
 62          </Typography>
 63          <Box sx={{ flexGrow: 1, display: 'flex', justifyContent: 'flex-end' }}>
 64            <Button color="inherit" onClick={handleLanguageMenu}>{t('Language')}</Button>
 65            <Menu
 66              anchorEl={anchorEl}
 67              open={Boolean(anchorEl)}
 68              onClose={() => setAnchorEl(null)}
 69            >
 70              <MenuItem onClick={() => handleLanguageChange('en')}>English</MenuItem>
 71              <MenuItem onClick={() => handleLanguageChange('ua')}>Ukrainian</MenuItem>
 72            </Menu>
 73            {user ? (
 74              <>
 75                {user.is_staff && <Button color="inherit" onClick={handleUsers}>{t('Users')}</Button>}
 76                {user.is_staff && <Button color="inherit" onClick={handleMines}>{t('Mines')}</Button>}
 77                {\!user.is_staff && <Button color="inherit" onClick={handleTrainings}>{t('Trainings')}</Button>}
 78                <Button color="inherit" onClick={handleProfile}>{t('Profile')}</Button>
 79                <Button color="inherit" onClick={handleLogout}>{t('Logout')}</Button>
 80              </>
 81            ) : (
 82              <>
 83                <Button color="inherit" onClick={handleLogin}>{t('Login')}</Button>
 84                <Button color="inherit" onClick={handleSignup}>{t('Sign up')}</Button>
 85              </>
 86            )}
 87          </Box>
 88        </Toolbar>
 89      </AppBar>
 90    );
 91  }
 92  
 93  export default Header;
